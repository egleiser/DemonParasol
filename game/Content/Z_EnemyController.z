/*//////////////////////////////////////////////////////////////////////////////////////////////////////////
//SCRIPT-Z_EnemyController.z
//AUTHOR-Travis Moore
//COURSE-GAM205
//COPYRIGHT-© 2014 DigiPen, All Rights Reserved.
//////////////////////////////////////////////////////////////////////////////////////////////////////////*/

class Z_EnemyController:ZilchComponent
{
    //DEPENDENCIES
    [Dependency]
    var Orientation : Orientation = null;
    
    //LUNGE PROPERTIES
    [Property]
    var TargetObjectPath:CogPath = null;
    [Property]
    var MaxAttackRange:Real = 5.0;
    [Property]
    var LungeSpeed:Real = 10.0;
    [Property]
    var TargetDetectionRange:Real = 10.0;
    [Property]
    var AttackTimeout:Real = 300.0;
    [Property]
    var MaxAttacks:Integer = 1;
    [Property]
    var HeadbuttAttackPercentage:Real = 0.5;
    
    //non-settable properties
    var TargetObject:Cog = null;
    var TargetDirection:Real3 = Real3();
    var TargetDistance:Real = Real();
    var OriginalPosition:Real3 = Real3();
    var LungeDistance:Real = Real();
    var MushroomRotation:Quaternion = Quaternion();
    var AttackTimer:Real = 0.0;
    
    /*//////////////////////////////////////////////////////////////////////////////////////////////////////
    //FUNCTION-Initialize
    //EXPLANATION-Initialize variables/functions so that we can use them
    //////////////////////////////////////////////////////////////////////////////////////////////////////*/
    function Initialize(init : CogInitializer)
    {
        //set the target of the enemy
        this.TargetObject = this.TargetObjectPath.Cog;
        
        //set the OriginalPosition of this object
        this.OriginalPosition = this.Owner.Transform.Translation;
        
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
    }
    
    /*//////////////////////////////////////////////////////////////////////////////////////////////////////
    //FUNCTION-OnLogicUpdate
    //EXPLANATION-Update every frame, perform actions of the enemy
    //////////////////////////////////////////////////////////////////////////////////////////////////////*/
    function OnLogicUpdate(event : UpdateEvent):Void
    {
        //do we have a target?
        if(this.TargetObject != null)
        {
            //call function to get distance/direction
            this.GetDistanceAndDirectionToTarget();
            
            //enemy in detection range?
            if(this.TargetDistance <= this.TargetDetectionRange)
            {
                //rotate the enemy
                this.RotateTowardsTarget(event);
                //DEBUG
                //Console.WriteLine("`this.TargetObject` in range");
                
                //can we attack yet?
                if(this.AttackTimer >= this.AttackTimeout)
                {
                    //DEBUG
                    Console.WriteLine("I can attack!");
                    //enemy at lunge range?
                    if(this.TargetDistance <= this.MaxAttackRange)
                    {
                        //choose an attack
                        this.ChooseAttackType(event);
                        //DEBUG
                        //Console.WriteLine("Attacking!");
                        
                        //reset LungeTimer
                        this.AttackTimer = 0.0;
                    }
                }
                
            }
            //increment LungeTimer
            ++this.AttackTimer;
        }
    }
    
    /*//////////////////////////////////////////////////////////////////////////////////////////////////////
    //FUNCTION-Lunge
    //EXPLANATION-Moves the enemy back and forth based on property set values
    //////////////////////////////////////////////////////////////////////////////////////////////////////*/
    function Lunge(event:UpdateEvent):Void
    {
        this.Owner.RigidBody.Velocity = -this.TargetDirection * this.LungeSpeed;
        var lungeDisplacement:Real3 = this.Owner.Transform.Translation + this.OriginalPosition;
        this.LungeDistance = Math.Length(lungeDisplacement);
    }
    /*//////////////////////////////////////////////////////////////////////////////////////////////////////
    //FUNCTION-ChooseAttackType
    //EXPLANATION-Chooses between lunging attacks and headbutt attacks
    //////////////////////////////////////////////////////////////////////////////////////////////////////*/
    function ChooseAttackType(event:UpdateEvent):Void
    {
        //pick a number between 0.0 and 1.0
        var random:Real = Random().Range(0.0, 1.0);
        
        //if random is less than or equal to the percentage chance of the HeadbuttAttackPercentage
        if(random <= this.HeadbuttAttackPercentage)
        {
            Console.WriteLine("Headbutt!");
        }
        //the rest of the attacks are normal lunges
        else
        {
            this.Lunge(event);
            Console.WriteLine("Lunging!");
        }
        
    }
    
    /*//////////////////////////////////////////////////////////////////////////////////////////////////////
    //FUNCTION-DistanceToTarget
    //EXPLANATION-Calculates the distance/direction between this enemy and the target object
    //////////////////////////////////////////////////////////////////////////////////////////////////////*/
    function GetDistanceAndDirectionToTarget():Void
    {
        var playerPos = this.TargetObject.Transform.Translation;
        var enemyPos = this.Owner.Transform.Translation;
        
        //enemy - player
        this.TargetDirection = enemyPos - playerPos;
        //length
        this.TargetDistance = Math.Length(this.TargetDirection);
        //normalize
        this.TargetDirection = Math.Normalize(this.TargetDirection);
    }
    
    /*//////////////////////////////////////////////////////////////////////////////////////////////////////
    //FUNCTION-DistanceToTarget
    //EXPLANATION-Calculates the distance/direction between this enemy and the target object
    //////////////////////////////////////////////////////////////////////////////////////////////////////*/
    function RotateTowardsTarget(event:UpdateEvent):Void
    {
        //store rotation
        this.MushroomRotation = this.Owner.Orientation.GetLookAtDirectionWithUpRotation(this.TargetDirection, Real3(0,0,0.5));
        //perform rotation through slerping
        this.Owner.Transform.Rotation = Math.Slerp(this.Owner.Transform.Rotation, this.MushroomRotation, 0.1);
    }
}
